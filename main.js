/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ClaudeAssistantPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_child_process = require("child_process");
var import_util = require("util");
var import_promises = require("fs/promises");
var import_os = require("os");
var execAsync = (0, import_util.promisify)(import_child_process.exec);
var DEFAULT_SETTINGS = {
  claudePath: "claude"
};
var ClaudeAssistantPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.claudePath = null;
  }
  async onload() {
    await this.loadSettings();
    this.logFilePath = "/Users/kazuph/Library/Mobile Documents/iCloud~md~obsidian/Documents/Obsidian Vault/.obsidian/plugins/claude-assistant/debug.log";
    await this.log("=== Claude Assistant Plugin Started ===");
    if (this.settings.claudePath && this.settings.claudePath !== "claude") {
      this.claudePath = this.settings.claudePath;
      console.log("Claude Assistant: Using configured path:", this.claudePath);
    } else {
      this.claudePath = await this.findClaudePath();
      if (this.claudePath) {
        console.log("Claude Assistant: Found Claude CLI at:", this.claudePath);
      } else {
        console.warn("Claude Assistant: Claude CLI not found");
      }
    }
    this.addCommand({
      id: "ask-claude",
      name: "Ask Claude about current note",
      callback: () => this.openQuestionModal()
    });
    this.addRibbonIcon("message-circle", "Ask Claude", () => {
      this.openQuestionModal();
    });
    this.addSettingTab(new ClaudeAssistantSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async log(message) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${message}
`;
    try {
      await (0, import_promises.appendFile)(this.logFilePath, logEntry, "utf8");
      console.log(`Claude Assistant: ${message}`);
    } catch (error) {
      console.error("Failed to write to log file:", error);
      console.log(`Claude Assistant: ${message}`);
    }
  }
  openQuestionModal() {
    new QuestionModal(this.app, async (question) => {
      await this.processClaudeRequest(question);
    }).open();
  }
  async processClaudeRequest(question) {
    await this.log(`processClaudeRequest started with question: ${question.substring(0, 100)}...`);
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) {
      await this.log("ERROR: No active markdown view found");
      new import_obsidian.Notice("No active markdown view found");
      return;
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      await this.log("ERROR: No active file found");
      new import_obsidian.Notice("No active file found");
      return;
    }
    try {
      const loadingNotice = new import_obsidian.Notice("Asking Claude...", 0);
      await this.log("Loading notice displayed");
      await this.log(`Using Claude path: ${this.claudePath}`);
      const noteContent = await this.app.vault.read(activeFile);
      await this.log(`Note content length: ${noteContent.length} characters`);
      await this.log(`Note content preview: ${noteContent.substring(0, 200)}...`);
      await this.log(`User question: "${question}"`);
      await this.log("Starting Claude command execution...");
      const result = await this.executeClaudeCommand(noteContent, question);
      await this.log(`Claude command completed. Result length: ${result.length} characters`);
      await this.log(`Claude response preview: ${result.substring(0, 300)}...`);
      loadingNotice.hide();
      await this.log("Loading notice hidden");
      const editor = activeView.editor;
      const cursor = editor.getCursor();
      editor.replaceRange("\n\n" + result + "\n\n", cursor);
      await this.log("Result inserted at cursor position");
      new import_obsidian.Notice(`Claude response inserted (${result.length} chars): ${result.substring(0, 50)}${result.length > 50 ? "..." : ""}`, 5e3);
      await this.log("processClaudeRequest completed successfully");
    } catch (error) {
      await this.log(`ERROR in processClaudeRequest: ${error.message}`);
      await this.log(`ERROR stack: ${error.stack}`);
      new import_obsidian.Notice(`Error: ${error.message}`);
      console.error("Claude Assistant Error:", error);
      console.error("Claude Assistant: Current path was:", this.claudePath);
    }
  }
  async findClaudePath() {
    const homeDir = (0, import_os.homedir)();
    const possiblePaths = [
      // よくあるClaude CLIのパス（権限問題を回避するため簡素化）
      "claude",
      // PATH上のclaude（最も権限問題が少ない）
      "/usr/local/bin/claude",
      "/opt/homebrew/bin/claude",
      `${homeDir}/.claude/local/claude`,
      `${homeDir}/.claude/local/node_modules/.bin/claude`,
      `${homeDir}/.config/claude/claude`,
      `${homeDir}/.local/bin/claude`
    ];
    console.log("Claude Assistant: Searching for Claude CLI...");
    for (const path of possiblePaths) {
      try {
        console.log(`Claude Assistant: Checking path: ${path}`);
        if (path === "claude") {
          try {
            const { stdout } = await execAsync("which claude");
            const resolvedPath = stdout.trim();
            if (resolvedPath) {
              console.log(`Claude Assistant: Found via which: ${resolvedPath}`);
              await this.testClaudePath(resolvedPath);
              return resolvedPath;
            }
          } catch (error) {
            console.log(`Claude Assistant: which claude failed: ${error.message}`);
          }
        } else {
          await (0, import_promises.access)(path);
          console.log(`Claude Assistant: File exists: ${path}`);
          await this.testClaudePath(path);
          return path;
        }
      } catch (error) {
        console.log(`Claude Assistant: Path ${path} failed: ${error.message}`);
        continue;
      }
    }
    console.warn("Claude Assistant: No valid Claude CLI path found");
    return null;
  }
  async testClaudePath(path) {
    return new Promise((resolve, reject) => {
      const child = (0, import_child_process.spawn)(path, ["--version"], {
        stdio: ["pipe", "pipe", "pipe"],
        timeout: 5e3
      });
      child.on("close", (code) => {
        if (code === 0) {
          console.log(`Claude Assistant: Successfully tested path: ${path}`);
          resolve();
        } else {
          reject(new Error(`Test failed with exit code ${code}`));
        }
      });
      child.on("error", (error) => {
        reject(error);
      });
      setTimeout(() => {
        child.kill();
        reject(new Error("Test timeout"));
      }, 5e3);
    });
  }
  async executeClaudeCommand(noteContent, question) {
    await this.log("executeClaudeCommand: Starting execution");
    const prompt = `${noteContent}

---------

${question}`;
    await this.log(`executeClaudeCommand: Prompt length: ${prompt.length} characters`);
    await this.log(`executeClaudeCommand: Prompt preview: ${prompt.substring(0, 200)}...`);
    const processEnv = {
      ...process.env,
      // Node.jsのPATHを明示的に追加
      PATH: [
        "/opt/homebrew/bin",
        "/usr/local/bin",
        "/Users/kazuph/.local/share/mise/installs/node/20.18.2/bin",
        process.env.PATH
      ].filter(Boolean).join(":")
    };
    await this.log(`executeClaudeCommand: Environment PATH: ${processEnv.PATH}`);
    const claudeCliPath = "/Users/kazuph/.claude/local/node_modules/@anthropic-ai/claude-code/cli.js";
    const nodeCommand = "/opt/homebrew/bin/node";
    const args = [claudeCliPath, "--verbose", "--print"];
    await this.log(`executeClaudeCommand: Command: ${nodeCommand}`);
    await this.log(`executeClaudeCommand: Args: [${args[0]}, ${args[1]}, ${args[2] ? "prompt(" + args[2].length + "chars)" : "MISSING_PROMPT"}]`);
    await this.log(`executeClaudeCommand: Working directory: ${(0, import_os.homedir)()}`);
    return new Promise(async (resolve, reject) => {
      var _a, _b, _c, _d;
      await this.log("executeClaudeCommand: Creating spawn process...");
      const child = (0, import_child_process.spawn)(nodeCommand, args, {
        stdio: ["pipe", "pipe", "pipe"],
        env: processEnv,
        cwd: (0, import_os.homedir)()
        // working directory を明示的に設定
      });
      await this.log(`executeClaudeCommand: Spawn created, PID: ${child.pid}`);
      let stdout = "";
      let stderr = "";
      (_a = child.stdout) == null ? void 0 : _a.setEncoding("utf8");
      (_b = child.stderr) == null ? void 0 : _b.setEncoding("utf8");
      child.on("spawn", async () => {
        await this.log("executeClaudeCommand: Process spawned successfully");
      });
      child.on("error", async (error) => {
        await this.log(`executeClaudeCommand: Process error: ${error.message}`);
        await this.log(`executeClaudeCommand: Error stack: ${error.stack}`);
        reject(new Error(`Claude CLI execution error: ${error.message}`));
      });
      (_c = child.stdout) == null ? void 0 : _c.on("data", async (data) => {
        const dataStr = data.toString();
        stdout += dataStr;
        await this.log(`executeClaudeCommand: stdout data received: ${dataStr.length} chars`);
        await this.log(`executeClaudeCommand: stdout preview: ${dataStr.substring(0, 200)}...`);
      });
      (_d = child.stderr) == null ? void 0 : _d.on("data", async (data) => {
        const dataStr = data.toString();
        stderr += dataStr;
        await this.log(`executeClaudeCommand: stderr data received: ${dataStr.length} chars`);
        await this.log(`executeClaudeCommand: stderr content: ${dataStr}`);
      });
      child.on("close", async (code) => {
        await this.log(`executeClaudeCommand: Process closed with code: ${code}`);
        await this.log(`executeClaudeCommand: Final stdout length: ${stdout.length}`);
        await this.log(`executeClaudeCommand: Final stderr length: ${stderr.length}`);
        if (code === 0) {
          await this.log("executeClaudeCommand: Success, resolving with stdout");
          resolve(stdout.trim());
        } else {
          await this.log(`executeClaudeCommand: Failed with exit code ${code}`);
          reject(new Error(`Claude CLI failed with exit code ${code}: ${stderr}`));
        }
      });
      const statusInterval = setInterval(async () => {
        await this.log(`executeClaudeCommand: Status check - Process exists: ${child.pid}, killed: ${child.killed}, connected: ${child.connected}`);
      }, 5e3);
      child.on("close", () => {
        clearInterval(statusInterval);
      });
      child.on("error", () => {
        clearInterval(statusInterval);
      });
      if (child.stdin) {
        await this.log("executeClaudeCommand: Writing prompt to stdin...");
        child.stdin.write(prompt);
        child.stdin.end();
        await this.log("executeClaudeCommand: Prompt written to stdin");
      } else {
        await this.log("executeClaudeCommand: ERROR - stdin not available");
        reject(new Error("stdin not available"));
        return;
      }
      await this.log("executeClaudeCommand: Promise setup complete, waiting for process...");
    });
  }
};
var QuestionModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.question = "";
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Ask Claude" });
    new import_obsidian.Setting(contentEl).setName("Question").setDesc("Enter your question about the current note").addTextArea((text) => {
      text.setPlaceholder("What would you like to ask Claude about this note?").setValue(this.question).onChange((value) => this.question = value);
      text.inputEl.rows = 4;
      text.inputEl.cols = 50;
      setTimeout(() => text.inputEl.focus(), 100);
    });
    new import_obsidian.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.close();
    })).addButton((btn) => btn.setButtonText("Ask Claude").setCta().onClick(() => {
      if (this.question.trim()) {
        this.close();
        this.onSubmit(this.question);
      } else {
        new import_obsidian.Notice("Please enter a question");
      }
    }));
    this.scope.register(["Mod"], "Enter", (evt) => {
      if (this.question.trim()) {
        this.close();
        this.onSubmit(this.question);
      }
      return false;
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ClaudeAssistantSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Claude Assistant Settings" });
    new import_obsidian.Setting(containerEl).setName("Claude CLI Path").setDesc('Path to Claude CLI executable. Leave as "claude" to use PATH, or specify full path like "/Users/username/.claude/local/claude"').addText((text) => text.setPlaceholder("/Users/username/.claude/local/claude").setValue(this.plugin.settings.claudePath).onChange(async (value) => {
      this.plugin.settings.claudePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Test Claude CLI").setDesc("Test if Claude CLI is accessible using the same method as actual execution").addButton((button) => button.setButtonText("Test Connection").onClick(async () => {
      button.setButtonText("Testing...");
      try {
        const testResult = await this.testClaudeExecution();
        new import_obsidian.Notice(`\u2705 Claude CLI test success! Response: ${testResult.substring(0, 100)}${testResult.length > 100 ? "..." : ""}`, 8e3);
        console.log("Claude CLI test result:", testResult);
        button.setButtonText("Test Connection");
      } catch (error) {
        new import_obsidian.Notice(`\u274C Claude CLI test failed: ${error.message}`, 5e3);
        console.error("Claude CLI test error:", error);
        button.setButtonText("Test Connection");
      }
    }));
    containerEl.createEl("h3", { text: "Debug Commands" });
    const debugCommands = [
      { name: "Test Node.js access", command: "/opt/homebrew/bin/node", args: ["--version"] },
      { name: "Test Claude CLI direct", command: "/opt/homebrew/bin/node", args: ["/Users/kazuph/.claude/local/node_modules/@anthropic-ai/claude-code/cli.js", "--version"] }
    ];
    debugCommands.forEach((cmd) => {
      new import_obsidian.Setting(containerEl).setName(cmd.name).addButton((button) => button.setButtonText("Test").onClick(async () => {
        button.setButtonText("Testing...");
        try {
          const result = await this.testCommand(cmd.command, cmd.args);
          new import_obsidian.Notice(`\u2705 ${cmd.name} success`);
          console.log(`${cmd.name} result:`, result);
          button.setButtonText("Test");
        } catch (error) {
          new import_obsidian.Notice(`\u274C ${cmd.name} failed: ${error.message}`);
          console.error(`${cmd.name} error:`, error);
          button.setButtonText("Test");
        }
      }));
    });
    containerEl.createEl("h3", { text: "macOS Permissions" });
    containerEl.createEl("p", {
      text: "If Claude CLI is not found, you may need to grant Obsidian additional permissions:"
    });
    const permissionsList = containerEl.createEl("ul");
    permissionsList.createEl("li", { text: "System Preferences > Privacy & Security > Full Disk Access > Add Obsidian" });
    permissionsList.createEl("li", { text: "System Preferences > Privacy & Security > Files and Folders > Grant Home folder access to Obsidian" });
    containerEl.createEl("p", {
      text: "After changing permissions, restart Obsidian and try again."
    });
  }
  async testClaudeExecution() {
    await this.plugin.log("testClaudeExecution: Starting test with actual prompt");
    const testPrompt = "\u3053\u3093\u306B\u3061\u306F";
    await this.plugin.log(`testClaudeExecution: Test input: "${testPrompt}"`);
    try {
      const result = await this.plugin.executeClaudeCommand("", testPrompt);
      await this.plugin.log(`testClaudeExecution: Test output: "${result}"`);
      await this.plugin.log("testClaudeExecution: Test completed successfully");
      return result;
    } catch (error) {
      await this.plugin.log(`testClaudeExecution: Test failed with error: ${error.message}`);
      throw error;
    }
  }
  async testCommand(command, args) {
    return new Promise((resolve, reject) => {
      var _a, _b;
      const child = (0, import_child_process.spawn)(command, args, {
        stdio: ["pipe", "pipe", "pipe"],
        env: { ...process.env },
        timeout: 1e4
      });
      let stdout = "";
      let stderr = "";
      (_a = child.stdout) == null ? void 0 : _a.on("data", (data) => {
        stdout += data.toString();
      });
      (_b = child.stderr) == null ? void 0 : _b.on("data", (data) => {
        stderr += data.toString();
      });
      child.on("close", (code) => {
        if (code === 0) {
          resolve(stdout || stderr);
        } else {
          reject(new Error(`Command failed with exit code ${code}: ${stderr || stdout}`));
        }
      });
      child.on("error", (error) => {
        reject(new Error(`Command error: ${error.message}`));
      });
      setTimeout(() => {
        child.kill();
        reject(new Error("Command timeout"));
      }, 1e4);
    });
  }
};
